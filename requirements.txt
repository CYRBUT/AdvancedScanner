#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                üöÄ ADVANCED SECURITY SCANNER PRO - INTERNATIONAL EDITION 2026             ‚ïë
‚ïë                 üõ°Ô∏è  Version 3.0 | Codename: 'NIGHTWATCH' | ROOT ACCESS                 ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
"""

import os
import sys
import time
import signal
import threading
import hashlib
import random
import subprocess
import importlib
import pkg_resources
from datetime import datetime
from colorama import init, Fore, Back, Style
from pyfiglet import Figlet

# Initialize colorama with custom settings
init(autoreset=True)

# Color Configuration - Dark Theme Focus
class Colors:
    # Primary Colors
    PRIMARY = Fore.BLACK + Style.BRIGHT
    SECONDARY = Fore.LIGHTBLACK_EX
    ACCENT = Fore.LIGHTRED_EX
    WARNING = Fore.LIGHTYELLOW_EX
    SUCCESS = Fore.LIGHTGREEN_EX
    ERROR = Fore.LIGHTRED_EX
    INFO = Fore.LIGHTCYAN_EX
    SCANNER = Fore.LIGHTMAGENTA_EX
    CRITICAL = Fore.RED + Style.BRIGHT
    
    # Text Variations
    BOLD = Style.BRIGHT
    DIM = Style.DIM
    NORMAL = Style.NORMAL
    REVERSE = Style.REVERSE
    
    # Backgrounds
    BG_DARK = Back.BLACK
    BG_RED = Back.RED
    BG_GREEN = Back.GREEN
    BG_BLUE = Back.BLUE
    BG_YELLOW = Back.YELLOW
    BG_MAGENTA = Back.MAGENTA

# Custom Figlet Fonts
FONTS = {
    'title': 'slant',
    'header': 'small',
    'subheader': 'digital',
    'banner': 'standard',
    'warning': 'mini'
}

# Required dependencies with minimum versions
REQUIREMENTS = {
    'requests': '2.32.0',
    'beautifulsoup4': '4.12.0',
    'colorama': '0.4.6',
    'lxml': '5.1.0',
    'dnspython': '2.4.0',
    'python-nmap': '0.7.1',
    'cryptography': '42.0.0',
    'urllib3': '2.0.0',
    'selenium': '4.20.0',
    'webdriver-manager': '4.0.0',
    'paramiko': '3.4.0',
    'scapy': '2.5.0',
    'pycryptodome': '3.20.0',
    'tqdm': '4.66.0',
    'pyfiglet': '1.0.2',
    'colorlog': '6.7.0',
    'psutil': '5.9.0',
    'netifaces': '0.11.0',
    'pillow': '10.0.0',
    'pandas': '2.0.0'
}

# Extended scanner modules
EXTENDED_SCANNERS = {
    'sql': 'SQL Injection',
    'xss': 'Cross-Site Scripting',
    'csrf': 'Cross-Site Request Forgery',
    'lfi_rfi': 'Local/Remote File Inclusion',
    'brute': 'Brute Force',
    'monolog': 'Monolog Hijacking',
    'info': 'Information Disclosure',
    'zero_day': 'Zero-Day Detection',
    'subdomain': 'Subdomain Enumeration',
    'port': 'Port Scanning',
    'directory': 'Directory Traversal',
    'ssl': 'SSL/TLS Analysis',
    'api': 'API Vulnerability',
    'cms': 'CMS Detection',
    'firewall': 'Firewall Bypass',
    'sqli_blind': 'Blind SQL Injection',
    'xxe': 'XML External Entity',
    'ssrf': 'Server-Side Request Forgery',
    'cors': 'CORS Misconfiguration',
    'jwt': 'JWT Token Analysis',
    'graphql': 'GraphQL Security',
    'websocket': 'WebSocket Security',
    'dns': 'DNS Security Analysis',
    'cache_poison': 'Cache Poisoning',
    'header': 'Security Headers',
    'csp': 'Content Security Policy',
    'hsts': 'HTTP Strict Transport Security',
    'clickjacking': 'Clickjacking Protection'
}

class DependencyManager:
    """Advanced dependency management system"""
    
    @staticmethod
    def check_dependency(package, required_version):
        """Check if a package is installed with correct version"""
        try:
            installed_version = pkg_resources.get_distribution(package).version
            if pkg_resources.parse_version(installed_version) >= pkg_resources.parse_version(required_version):
                return True, installed_version
            else:
                return False, installed_version
        except pkg_resources.DistributionNotFound:
            return False, None
        except Exception as e:
            return False, str(e)
    
    @staticmethod
    def install_dependency(package, version=None):
        """Install a dependency using pip"""
        install_cmd = [sys.executable, "-m", "pip", "install", "--upgrade"]
        if version:
            package_spec = f"{package}=={version}"
        else:
            package_spec = package
        
        install_cmd.append(package_spec)
        
        try:
            print(f"{Colors.INFO}[*] Installing {Colors.WARNING}{package}...")
            result = subprocess.run(install_cmd, check=True, capture_output=True, text=True)
            return True, result.stdout
        except subprocess.CalledProcessError as e:
            return False, e.stderr
    
    @staticmethod
    def check_all_dependencies():
        """Check all required dependencies"""
        print(f"{Colors.INFO}{'‚îÄ' * 80}")
        print(f"{Colors.SCANNER}üîß DEPENDENCY VERIFICATION")
        print(f"{Colors.INFO}{'‚îÄ' * 80}")
        
        dependencies_status = {}
        missing_dependencies = []
        outdated_dependencies = []
        
        for package, required_version in REQUIREMENTS.items():
            is_ok, installed_version = DependencyManager.check_dependency(package, required_version)
            
            if is_ok:
                print(f"{Colors.SUCCESS}[‚úì] {Colors.PRIMARY}{package:<20} {Colors.SECONDARY}v{installed_version}")
                dependencies_status[package] = {
                    'installed': True,
                    'version': installed_version,
                    'required': required_version,
                    'status': 'OK'
                }
            elif installed_version:
                print(f"{Colors.WARNING}[!] {Colors.PRIMARY}{package:<20} {Colors.SECONDARY}v{installed_version} {Colors.WARNING}< v{required_version}")
                outdated_dependencies.append(package)
                dependencies_status[package] = {
                    'installed': True,
                    'version': installed_version,
                    'required': required_version,
                    'status': 'OUTDATED'
                }
            else:
                print(f"{Colors.ERROR}[‚úó] {Colors.PRIMARY}{package:<20} {Colors.ERROR}NOT INSTALLED")
                missing_dependencies.append(package)
                dependencies_status[package] = {
                    'installed': False,
                    'version': None,
                    'required': required_version,
                    'status': 'MISSING'
                }
        
        print(f"{Colors.INFO}{'‚îÄ' * 80}")
        
        if missing_dependencies or outdated_dependencies:
            return False, dependencies_status, missing_dependencies, outdated_dependencies
        return True, dependencies_status, [], []
    
    @staticmethod
    def auto_fix_dependencies(missing, outdated):
        """Automatically install missing and update outdated dependencies"""
        print(f"{Colors.WARNING}{'‚ö†' * 80}")
        print(f"{Colors.WARNING} AUTOMATIC DEPENDENCY RESOLUTION")
        print(f"{Colors.WARNING}{'‚ö†' * 80}")
        
        all_to_install = missing + outdated
        success_count = 0
        fail_count = 0
        
        for package in all_to_install:
            required_version = REQUIREMENTS.get(package)
            
            if package in missing:
                print(f"\n{Colors.INFO}[*] Installing missing: {Colors.WARNING}{package} v{required_version}")
            else:
                print(f"\n{Colors.INFO}[*] Updating outdated: {Colors.WARNING}{package} to v{required_version}")
            
            success, message = DependencyManager.install_dependency(package, required_version)
            
            if success:
                print(f"{Colors.SUCCESS}[‚úì] Successfully installed {package}")
                success_count += 1
            else:
                print(f"{Colors.ERROR}[‚úó] Failed to install {package}: {message}")
                fail_count += 1
        
        return success_count, fail_count

class AdvancedScannerPro:
    def __init__(self):
        self.scanners = {}
        self.results = {}
        self.is_running = False
        self.current_target = None
        self.scan_id = None
        self.session_id = hashlib.md5(str(time.time()).encode()).hexdigest()[:8]
        
        # Statistics
        self.stats = {
            'vulnerabilities_found': 0,
            'scans_completed': 0,
            'start_time': None,
            'end_time': None,
            'total_modules': len(EXTENDED_SCANNERS)
        }
        
        # Configuration
        self.config = {
            'max_threads': 15,
            'timeout': 30,
            'retry_attempts': 3,
            'aggressive_mode': False,
            'stealth_mode': False,
            'proxy_enabled': False,
            'tor_routing': False,
            'rate_limit': 10,
            'user_agent': 'SecurityScanner/3.0'
        }
        
        # Initialize extended features
        self.dependency_manager = DependencyManager()
        self.dependency_status = {}
        
    def display_banner(self):
        """Display enhanced ASCII banner with colors"""
        os.system('clear' if os.name == 'posix' else 'cls')
        
        # Generate random banner color
        banner_colors = [Colors.INFO, Colors.SCANNER, Colors.ACCENT, Colors.SUCCESS]
        selected_color = random.choice(banner_colors)
        
        f = Figlet(font=FONTS['title'])
        banner_text = f.renderText('SECURITY SCANNER')
        
        # Generate sub-banner
        f2 = Figlet(font=FONTS['banner'])
        sub_banner = f2.renderText('PRO EDITION 2026')
        
        print(f"\n{selected_color}{'‚ïê' * 100}")
        print(f"{selected_color}{banner_text}")
        print(f"{Colors.CRITICAL}{sub_banner}")
        
        # Additional decorative elements
        print(f"{Colors.SECONDARY}{'‚îÄ' * 100}")
        print(f"{Colors.INFO}‚ïë{Colors.PRIMARY}   Version: {Colors.SUCCESS}3.0 PRO 2026 {Colors.SECONDARY}|{Colors.PRIMARY} Session: {Colors.WARNING}{self.session_id}")
        print(f"{Colors.INFO}‚ïë{Colors.PRIMARY}   Status: {Colors.SUCCESS}ACTIVE {Colors.SECONDARY}|{Colors.PRIMARY} Mode: {Colors.ACCENT}ROOT PRIVILEGES")
        print(f"{Colors.INFO}‚ïë{Colors.PRIMARY}   Time: {Colors.WARNING}{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"{Colors.INFO}‚ïë{Colors.PRIMARY}   Modules: {Colors.INFO}{self.stats['total_modules']} {Colors.SECONDARY}|{Colors.PRIMARY} Dependencies: {Colors.SUCCESS}{len(REQUIREMENTS)}")
        print(f"{Colors.SECONDARY}{'‚îÄ' * 100}")
        print(f"{Colors.DIM}{' ' * 35}üîí ADVANCED CYBERSECURITY FRAMEWORK üîí")
        print(f"{Colors.SECONDARY}{'‚ïê' * 100}\n{Style.RESET_ALL}")
    
    def load_scanners(self):
        """Dynamically load all scanner modules with enhanced logging"""
        loaded_count = 0
        failed_modules = []
        
        print(f"{Colors.INFO}{'‚îÄ' * 100}")
        print(f"{Colors.SCANNER}üì¶ LOADING SECURITY MODULES")
        print(f"{Colors.INFO}{'‚îÄ' * 100}")
        
        # Try to load each scanner
        for module_code, module_name in EXTENDED_SCANNERS.items():
            try:
                # Dynamic import based on module code
                module_path = f"scanners.{module_code}_scanner"
                module = importlib.import_module(module_path)
                scanner_class = getattr(module, f"{module_code.capitalize()}Scanner")
                self.scanners[module_code] = scanner_class()
                
                print(f"{Colors.SUCCESS}[‚úì] {Colors.PRIMARY}{module_name:<30} {Colors.SECONDARY}Loaded")
                loaded_count += 1
                
            except ImportError as e:
                print(f"{Colors.WARNING}[!] {Colors.PRIMARY}{module_name:<30} {Colors.SECONDARY}Skipped - Module not found")
                failed_modules.append(module_name)
            except Exception as e:
                print(f"{Colors.ERROR}[‚úó] {Colors.PRIMARY}{module_name:<30} {Colors.SECONDARY}Error: {str(e)[:50]}...")
                failed_modules.append(module_name)
        
        print(f"{Colors.INFO}{'‚îÄ' * 100}")
        print(f"{Colors.PRIMARY}Modules Loaded: {Colors.SUCCESS}{loaded_count}/{len(EXTENDED_SCANNERS)}")
        
        if failed_modules:
            print(f"{Colors.PRIMARY}Failed Modules: {Colors.ERROR}{len(failed_modules)}")
            print(f"{Colors.SECONDARY}   ‚îî‚îÄ {', '.join(failed_modules[:5])}")
            if len(failed_modules) > 5:
                print(f"{Colors.SECONDARY}   ‚îî‚îÄ ... and {len(failed_modules) - 5} more")
        
        print(f"{Colors.INFO}{'‚îÄ' * 100}\n")
    
    def set_target(self, target):
        """Set target for scanning with validation"""
        from urllib.parse import urlparse
        
        # Add protocol if missing
        if not target.startswith(('http://', 'https://')):
            target = 'http://' + target
        
        # Validate URL
        try:
            result = urlparse(target)
            if all([result.scheme, result.netloc]):
                self.current_target = target
                self.scan_id = hashlib.sha256(target.encode()).hexdigest()[:12]
                
                print(f"{Colors.SUCCESS}[‚úì] {Colors.PRIMARY}Target set: {Colors.INFO}{self.current_target}")
                print(f"{Colors.SECONDARY}   ‚îî‚îÄ Scan ID: {Colors.WARNING}{self.scan_id}")
                print(f"{Colors.SECONDARY}   ‚îî‚îÄ Hostname: {Colors.INFO}{result.netloc}")
                print(f"{Colors.SECONDARY}   ‚îî‚îÄ Protocol: {Colors.INFO}{result.scheme.upper()}")
                
                # Additional target analysis
                self.analyze_target(target)
                return True
            else:
                print(f"{Colors.ERROR}[‚úó] Invalid target URL")
                return False
        except Exception as e:
            print(f"{Colors.ERROR}[‚úó] URL validation error: {e}")
            return False
    
    def analyze_target(self, target):
        """Perform initial target analysis"""
        print(f"{Colors.INFO}[*] {Colors.PRIMARY}Performing initial target analysis...")
        
        try:
            import socket
            from urllib.parse import urlparse
            
            parsed = urlparse(target)
            hostname = parsed.netloc
            
            # Resolve IP
            ip_address = socket.gethostbyname(hostname)
            print(f"{Colors.SECONDARY}   ‚îú‚îÄ IP Address: {Colors.INFO}{ip_address}")
            
            # Check if site is reachable
            import requests
            try:
                response = requests.get(target, timeout=5, verify=False)
                print(f"{Colors.SECONDARY}   ‚îú‚îÄ HTTP Status: {Colors.INFO}{response.status_code}")
                print(f"{Colors.SECONDARY}   ‚îú‚îÄ Server: {Colors.INFO}{response.headers.get('Server', 'Unknown')}")
                print(f"{Colors.SECONDARY}   ‚îî‚îÄ Content Length: {Colors.INFO}{len(response.content)} bytes")
            except:
                print(f"{Colors.WARNING}   ‚îî‚îÄ Target appears to be unreachable")
                
        except Exception as e:
            print(f"{Colors.WARNING}   ‚îî‚îÄ Analysis incomplete: {e}")
    
    def run_scan(self, scan_types, options=None):
        """Execute selected scans with enhanced parallel processing"""
        if not self.current_target:
            print(f"{Colors.ERROR}[‚úó] {Colors.PRIMARY}No target set!")
            return False
        
        # Validate scan types
        valid_scans = []
        invalid_scans = []
        
        for scan_type in scan_types:
            if scan_type in self.scanners:
                valid_scans.append(scan_type)
            else:
                invalid_scans.append(scan_type)
        
        if invalid_scans:
            print(f"{Colors.WARNING}[!] {Colors.PRIMARY}Invalid scan types: {Colors.WARNING}{', '.join(invalid_scans)}")
            if not valid_scans:
                return False
        
        self.is_running = True
        self.stats['start_time'] = datetime.now()
        self.stats['vulnerabilities_found'] = 0
        
        # Display scan header
        print(f"\n{Colors.INFO}{'‚ïê' * 100}")
        print(f"{Colors.SCANNER}üõ°Ô∏è   INITIATING ADVANCED SECURITY SCAN PROTOCOL")
        print(f"{Colors.INFO}{'‚ïê' * 100}")
        print(f"{Colors.PRIMARY}Target: {Colors.INFO}{self.current_target}")
        print(f"{Colors.PRIMARY}Scan ID: {Colors.WARNING}{self.scan_id}")
        print(f"{Colors.PRIMARY}Valid Scans: {Colors.SUCCESS}{', '.join([EXTENDED_SCANNERS.get(st, st) for st in valid_scans])}")
        print(f"{Colors.PRIMARY}Start Time: {Colors.INFO}{self.stats['start_time'].strftime('%H:%M:%S')}")
        print(f"{Colors.INFO}{'‚îÄ' * 100}\n")
        
        # Initialize progress tracking
        from tqdm import tqdm
        completed = 0
        total = len(valid_scans)
        
        # Create thread pool
        threads = []
        results_lock = threading.Lock()
        
        # Initialize progress bar
        pbar = tqdm(total=total, desc=f"{Colors.INFO}Scan Progress", 
                   bar_format="{l_bar}{bar}| {n_fmt}/{total_fmt} [{elapsed}<{remaining}]")
        
        def worker(scan_type):
            nonlocal completed
            try:
                if scan_type in self.scanners:
                    result = self.scanners[scan_type].scan(self.current_target, options or {})
                    
                    with results_lock:
                        self.results[scan_type] = result
                        
                        if result.get('vulnerabilities'):
                            vuln_count = len(result['vulnerabilities'])
                            self.stats['vulnerabilities_found'] += vuln_count
                            tqdm.write(f"{Colors.ERROR}[!] {Colors.PRIMARY}{EXTENDED_SCANNERS.get(scan_type, scan_type)}: {Colors.ERROR}{vuln_count} vulnerabilities")
                        else:
                            tqdm.write(f"{Colors.SUCCESS}[‚úì] {Colors.PRIMARY}{EXTENDED_SCANNERS.get(scan_type, scan_type)}: {Colors.SUCCESS}Secure")
                else:
                    tqdm.write(f"{Colors.WARNING}[!] {Colors.PRIMARY}Scanner {scan_type} not available")
                    
            except Exception as e:
                tqdm.write(f"{Colors.ERROR}[‚úó] {Colors.PRIMARY}{EXTENDED_SCANNERS.get(scan_type, scan_type)} failed: {str(e)[:50]}")
            finally:
                completed += 1
                pbar.update(1)
        
        # Start threads with thread pool
        import concurrent.futures
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.config['max_threads']) as executor:
            futures = {executor.submit(worker, scan_type): scan_type for scan_type in valid_scans}
            
            for future in concurrent.futures.as_completed(futures):
                scan_type = futures[future]
                try:
                    future.result()
                except Exception as e:
                    tqdm.write(f"{Colors.ERROR}[‚úó] {scan_type} thread error: {e}")
        
        pbar.close()
        
        # Calculate statistics
        self.stats['end_time'] = datetime.now()
        self.stats['scans_completed'] = completed
        duration = (self.stats['end_time'] - self.stats['start_time']).total_seconds()
        
        # Display comprehensive summary
        self.display_scan_summary(duration, completed, total)
        
        self.is_running = False
        
        # Save results
        self.save_results()
        
        # Generate report
        self.generate_report()
        
        return True
    
    def display_scan_summary(self, duration, completed, total):
        """Display comprehensive scan summary"""
        print(f"\n{Colors.SUCCESS}{'‚ïê' * 100}")
        print(f"{Colors.SUCCESS}‚úÖ ADVANCED SECURITY SCAN COMPLETED")
        print(f"{Colors.SUCCESS}{'‚ïê' * 100}")
        
        # Create summary table
        print(f"{Colors.PRIMARY}{'Metric':<25} {'Value':<30} {'Status':<20}")
        print(f"{Colors.SECONDARY}{'‚îÄ' * 75}")
        
        metrics = [
            ("Duration", f"{duration:.2f} seconds", "INFO"),
            ("Scans Completed", f"{completed}/{total}", "SUCCESS" if completed == total else "WARNING"),
            ("Vulnerabilities", str(self.stats['vulnerabilities_found']), 
             "ERROR" if self.stats['vulnerabilities_found'] > 0 else "SUCCESS"),
            ("Success Rate", f"{(completed/total*100):.1f}%", 
             "SUCCESS" if (completed/total) > 0.8 else "WARNING"),
            ("Scan Speed", f"{(total/duration):.2f} scans/sec", "INFO"),
            ("Overall Status", 
             "CRITICAL" if self.stats['vulnerabilities_found'] > 5 else 
             "VULNERABLE" if self.stats['vulnerabilities_found'] > 0 else "SECURE",
             "ERROR" if self.stats['vulnerabilities_found'] > 5 else 
             "WARNING" if self.stats['vulnerabilities_found'] > 0 else "SUCCESS")
        ]
        
        for metric, value, status in metrics:
            color = getattr(Colors, status)
            print(f"{Colors.PRIMARY}{metric:<25} {color}{value:<30} {color}{status:<20}")
        
        print(f"{Colors.SUCCESS}{'‚ïê' * 100}\n")
    
    def save_results(self):
        """Save scan results with multiple enhanced formats"""
        if not self.results:
            print(f"{Colors.WARNING}[!] No results to save")
            return
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        base_filename = f"scan_{self.scan_id}_{timestamp}"
        
        # Ensure reports directory exists
        os.makedirs("reports", exist_ok=True)
        
        # Save formats
        formats = [
            ('json', self._save_json_report),
            ('html', self._save_html_report),
            ('txt', self._save_text_report),
            ('csv', self._save_csv_report),
            ('pdf', self._save_pdf_report)
        ]
        
        for fmt_name, save_func in formats:
            try:
                filename = f"reports/{base_filename}.{fmt_name}"
                save_func(filename)
                print(f"{Colors.SUCCESS}[‚úì] {Colors.PRIMARY}{fmt_name.upper()} report saved: {Colors.INFO}{filename}")
            except Exception as e:
                print(f"{Colors.WARNING}[!] {Colors.PRIMARY}{fmt_name.upper()} report failed: {Colors.SECONDARY}{str(e)[:50]}...")
    
    def _save_json_report(self, filename):
        """Save report in JSON format"""
        import json
        
        report = {
            'metadata': {
                'target': self.current_target,
                'scan_id': self.scan_id,
                'timestamp': datetime.now().isoformat(),
                'duration': (self.stats['end_time'] - self.stats['start_time']).total_seconds(),
                'vulnerabilities_found': self.stats['vulnerabilities_found'],
                'scans_completed': self.stats['scans_completed']
            },
            'configuration': self.config,
            'results': self.results,
            'statistics': self.stats
        }
        
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
    
    def _save_html_report(self, filename):
        """Generate enhanced HTML report"""
        html_content = """
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Security Scan Report - """ + self.scan_id + """</title>
            <style>
                body { 
                    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
                    background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
                    color: #e0e0e0; 
                    margin: 0;
                    padding: 20px;
                }
                .container {
                    max-width: 1200px;
                    margin: 0 auto;
                    background: rgba(20, 20, 30, 0.9);
                    border-radius: 15px;
                    padding: 30px;
                    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
                }
                .header { 
                    background: linear-gradient(90deg, #000428 0%, #004e92 100%);
                    padding: 25px;
                    border-radius: 10px;
                    border: 2px solid #00ff00;
                    margin-bottom: 30px;
                    text-align: center;
                }
                .vulnerable { color: #ff4757; font-weight: bold; }
                .secure { color: #2ed573; font-weight: bold; }
                .warning { color: #ffa502; }
                .info { color: #1e90ff; }
                .critical { color: #ff0000; font-weight: bold; text-shadow: 0 0 10px #ff0000; }
                .section { 
                    margin: 25px 0; 
                    padding: 20px;
                    background: rgba(30, 30, 46, 0.8);
                    border-radius: 10px;
                    border-left: 5px solid #1e90ff;
                }
                .scan-result {
                    padding: 15px;
                    margin: 10px 0;
                    background: rgba(40, 40, 60, 0.6);
                    border-radius: 8px;
                    transition: all 0.3s;
                }
                .scan-result:hover {
                    background: rgba(50, 50, 80, 0.8);
                    transform: translateX(5px);
                }
                h1 { color: #00ff00; text-shadow: 0 0 10px #00ff00; }
                h2 { color: #1e90ff; border-bottom: 2px solid #1e90ff; padding-bottom: 10px; }
                h3 { color: #ffa502; }
                table {
                    width: 100%;
                    border-collapse: collapse;
                    margin: 20px 0;
                }
                th, td {
                    padding: 12px;
                    text-align: left;
                    border-bottom: 1px solid #444;
                }
                th {
                    background: rgba(30, 30, 50, 0.9);
                    color: #00ff00;
                }
                tr:hover {
                    background: rgba(60, 60, 90, 0.5);
                }
                .stats-grid {
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                    gap: 20px;
                    margin: 20px 0;
                }
                .stat-box {
                    background: rgba(40, 40, 60, 0.8);
                    padding: 20px;
                    border-radius: 10px;
                    text-align: center;
                    border: 1px solid #444;
                }
                .stat-value {
                    font-size: 2em;
                    font-weight: bold;
                    margin: 10px 0;
                }
                .footer {
                    margin-top: 40px;
                    padding: 20px;
                    text-align: center;
                    color: #888;
                    border-top: 1px solid #444;
                }
            </style>
        </head>
        <body>
            <div class="container">
                <div class="header">
                    <h1>üîí ADVANCED SECURITY SCAN REPORT</h1>
                    <h2>Generated by Security Scanner Pro v3.0</h2>
                </div>
        """
        
        # Add metadata
        html_content += f"""
                <div class="section">
                    <h2>üìä Scan Information</h2>
                    <table>
                        <tr><th>Parameter</th><th>Value</th></tr>
                        <tr><td>Target</td><td>{self.current_target}</td></tr>
                        <tr><td>Scan ID</td><td>{self.scan_id}</td></tr>
                        <tr><td>Timestamp</td><td>{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</td></tr>
                        <tr><td>Duration</td><td>{(self.stats['end_time'] - self.stats['start_time']).total_seconds():.2f} seconds</td></tr>
                        <tr><td>Vulnerabilities</td><td class="{'critical' if self.stats['vulnerabilities_found'] > 0 else 'secure'}">{self.stats['vulnerabilities_found']}</td></tr>
                    </table>
                </div>
        """
        
        # Add statistics
        html_content += """
                <div class="section">
                    <h2>üìà Statistics</h2>
                    <div class="stats-grid">
        """
        
        stats_items = [
            ("Scans Completed", f"{self.stats['scans_completed']}", "info"),
            ("Success Rate", f"{(self.stats['scans_completed']/self.stats['total_modules']*100):.1f}%", "info"),
            ("Overall Status", "CRITICAL" if self.stats['vulnerabilities_found'] > 5 else 
                              "VULNERABLE" if self.stats['vulnerabilities_found'] > 0 else "SECURE", 
             "critical" if self.stats['vulnerabilities_found'] > 5 else 
             "warning" if self.stats['vulnerabilities_found'] > 0 else "secure")
        ]
        
        for title, value, css_class in stats_items:
            html_content += f"""
                        <div class="stat-box">
                            <h3>{title}</h3>
                            <div class="stat-value {css_class}">{value}</div>
                        </div>
            """
        
        html_content += """
                    </div>
                </div>
        """
        
        # Add results
        html_content += """
                <div class="section">
                    <h2>üîç Scan Results</h2>
        """
        
        for scan_type, result in self.results.items():
            status = "VULNERABLE" if result.get('vulnerabilities') else "SECURE"
            css_class = "critical" if result.get('vulnerabilities') else "secure"
            vuln_count = len(result.get('vulnerabilities', []))
            
            html_content += f"""
                    <div class="scan-result">
                        <h3>{EXTENDED_SCANNERS.get(scan_type, scan_type)} - <span class="{css_class}">{status}</span></h3>
            """
            
            if result.get('vulnerabilities'):
                html_content += f"<p class='warning'>Found {vuln_count} vulnerabilities:</p><ul>"
                for vuln in result['vulnerabilities'][:10]:  # Show first 10
                    html_content += f"<li class='vulnerable'>{vuln}</li>"
                if vuln_count > 10:
                    html_content += f"<li class='info'>... and {vuln_count - 10} more</li>"
                html_content += "</ul>"
            else:
                html_content += "<p class='secure'>No vulnerabilities detected.</p>"
            
            html_content += "</div>"
        
        html_content += """
                </div>
                <div class="footer">
                    <p>¬© 2026 Security Scanner Pro - Advanced Cybersecurity Framework</p>
                    <p>This report was automatically generated. For security concerns, contact your security team.</p>
                </div>
            </div>
        </body>
        </html>
        """
        
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(html_content)
    
    def _save_text_report(self, filename):
        """Save detailed text report"""
        with open(filename, 'w', encoding='utf-8') as f:
            f.write("=" * 80 + "\n")
            f.write("ADVANCED SECURITY SCAN REPORT\n")
            f.write("=" * 80 + "\n\n")
            
            f.write(f"Target: {self.current_target}\n")
            f.write(f"Scan ID: {self.scan_id}\n")
            f.write(f"Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"Duration: {(self.stats['end_time'] - self.stats['start_time']).total_seconds():.2f} seconds\n")
            f.write(f"Vulnerabilities Found: {self.stats['vulnerabilities_found']}\n")
            f.write(f"Scans Completed: {self.stats['scans_completed']}/{self.stats['total_modules']}\n")
            f.write("\n" + "=" * 80 + "\n\n")
            
            for scan_type, result in self.results.items():
                f.write(f"[{EXTENDED_SCANNERS.get(scan_type, scan_type)}]\n")
                f.write(f"Status: {'VULNERABLE' if result.get('vulnerabilities') else 'SECURE'}\n")
                
                if result.get('vulnerabilities'):
                    f.write(f"Vulnerabilities ({len(result['vulnerabilities'])}):\n")
                    for i, vuln in enumerate(result['vulnerabilities'][:20], 1):  # Limit to 20
                        f.write(f"  {i:3d}. {vuln}\n")
                    if len(result['vulnerabilities']) > 20:
                        f.write(f"  ... and {len(result['vulnerabilities']) - 20} more vulnerabilities\n")
                else:
                    f.write("  No vulnerabilities detected\n")
                f.write("\n")
    
    def _save_csv_report(self, filename):
        """Save report in CSV format"""
        import csv
        
        with open(filename, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerow(['Scan Type', 'Status', 'Vulnerabilities Found', 'Details'])
            
            for scan_type, result in self.results.items():
                status = 'VULNERABLE' if result.get('vulnerabilities') else 'SECURE'
                vuln_count = len(result.get('vulnerabilities', []))
                details = '; '.join(result.get('vulnerabilities', []))[:200]  # Limit length
                writer.writerow([
                    EXTENDED_SCANNERS.get(scan_type, scan_type),
                    status,
                    vuln_count,
                    details
                ])
    
    def _save_pdf_report(self, filename):
        """Save report as PDF (if dependencies available)"""
        try:
            from reportlab.lib.pagesizes import letter
            from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
            from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
            from reportlab.lib import colors
            from reportlab.lib.units import inch
            
            doc = SimpleDocTemplate(filename, pagesize=letter)
            styles = getSampleStyleSheet()
            story = []
            
            # Title
            title_style = ParagraphStyle(
                'CustomTitle',
                parent=styles['Heading1'],
                fontSize=24,
                spaceAfter=30,
                textColor=colors.darkblue
            )
            story.append(Paragraph("Security Scan Report", title_style))
            
            # Add content
            story.append(Paragraph(f"Target: {self.current_target}", styles["Normal"]))
            story.append(Spacer(1, 12))
            
            doc.build(story)
            return True
            
        except ImportError:
            print(f"{Colors.WARNING}[!] PDF report requires reportlab module")
            return False
    
    def generate_report(self):
        """Generate comprehensive scan report with recommendations"""
        print(f"{Colors.INFO}{'‚îÄ' * 100}")
        print(f"{Colors.SCANNER}üìä GENERATING COMPREHENSIVE SECURITY ASSESSMENT")
        print(f"{Colors.INFO}{'‚îÄ' * 100}")
        
        # Analyze results and generate recommendations
        critical_vulns = 0
        high_vulns = 0
        medium_vulns = 0
        low_vulns = 0
        
        for scan_type, result in self.results.items():
            vulns = result.get('vulnerabilities', [])
            for vuln in vulns:
                vuln_lower = vuln.lower()
                if any(word in vuln_lower for word in ['critical', 'remote code execution', 'sql injection', 'xss']):
                    critical_vulns += 1
                elif any(word in vuln_lower for word in ['high', 'privilege escalation', 'data leak']):
                    high_vulns += 1
                elif any(word in vuln_lower for word in ['medium', 'csrf', 'lfi']):
                    medium_vulns += 1
                else:
                    low_vulns += 1
        
        print(f"{Colors.PRIMARY}Vulnerability Severity Breakdown:")
        print(f"{Colors.SECONDARY}   ‚îú‚îÄ {Colors.CRITICAL}Critical: {critical_vulns}")
        print(f"{Colors.SECONDARY}   ‚îú‚îÄ {Colors.ERROR}High: {high_vulns}")
        print(f"{Colors.SECONDARY}   ‚îú‚îÄ {Colors.WARNING}Medium: {medium_vulns}")
        print(f"{Colors.SECONDARY}   ‚îî‚îÄ {Colors.INFO}Low: {low_vulns}")
        
        # Generate recommendations
        print(f"\n{Colors.PRIMARY}Security Recommendations:")
        if critical_vulns > 0:
            print(f"{Colors.CRITICAL}   ‚ö†  IMMEDIATE ACTION REQUIRED: Address critical vulnerabilities")
        if high_vulns > 0:
            print(f"{Colors.ERROR}   ‚ö†  High priority: Fix high-severity issues within 48 hours")
        
        # General recommendations
        recommendations = [
            "Enable Web Application Firewall (WAF)",
            "Implement proper input validation",
            "Update all software components",
            "Configure security headers (CSP, HSTS)",
            "Regular security audits",
            "Implement rate limiting",
            "Enable logging and monitoring"
        ]
        
        for i, rec in enumerate(recommendations, 1):
            print(f"{Colors.SECONDARY}   {i:2d}. {Colors.INFO}{rec}")
        
        print(f"\n{Colors.SUCCESS}[‚úì] {Colors.PRIMARY}Comprehensive report generated")
        print(f"{Colors.INFO}{'‚îÄ' * 100}\n")
    
    def signal_handler(self, sig, frame):
        """Handle interrupt signals gracefully"""
        print(f"\n{Colors.WARNING}{'!' * 100}")
        print(f"{Colors.WARNING}‚ö†Ô∏è   SCAN INTERRUPTED BY USER - EMERGENCY SHUTDOWN")
        print(f"{Colors.WARNING}{'!' * 100}")
        
        if self.is_running:
            print(f"{Colors.WARNING}[!] {Colors.PRIMARY}Saving partial results...")
            self.save_results()
        
        print(f"{Colors.INFO}[*] {Colors.PRIMARY}Cleaning up resources...")
        print(f"{Colors.SUCCESS}[‚úì] {Colors.PRIMARY}Scanner shutdown complete")
        sys.exit(0)

def check_system_requirements():
    """Check system requirements and capabilities"""
    print(f"{Colors.INFO}{'‚îÄ' * 100}")
    print(f"{Colors.SCANNER}üñ•Ô∏è  SYSTEM REQUIREMENTS CHECK")
    print(f"{Colors.INFO}{'‚îÄ' * 100}")
    
    requirements_met = True
    
    # Check Python version
    python_version = sys.version_info
    print(f"{Colors.PRIMARY}Python Version: {Colors.INFO}{python_version.major}.{python_version.minor}.{python_version.micro}")
    if python_version < (3, 8):
        print(f"{Colors.ERROR}[‚úó] {Colors.PRIMARY}Python 3.8 or higher required")
        requirements_met = False
    
    # Check available memory
    try:
        import psutil
        memory = psutil.virtual_memory()
        memory_gb = memory.total / (1024**3)
        print(f"{Colors.PRIMARY}System Memory: {Colors.INFO}{memory_gb:.1f} GB")
        if memory_gb < 2:
            print(f"{Colors.WARNING}[!] {Colors.PRIMARY}Low memory - 2+ GB recommended")
    except:
        print(f"{Colors.WARNING}[!] {Colors.PRIMARY}Memory check unavailable")
    
    # Check disk space
    try:
        disk = psutil.disk_usage('/')
        disk_free_gb = disk.free / (1024**3)
        print(f"{Colors.PRIMARY}Disk Space: {Colors.INFO}{disk_free_gb:.1f} GB free")
        if disk_free_gb < 1:
            print(f"{Colors.WARNING}[!] {Colors.PRIMARY}Low disk space")
    except:
        print(f"{Colors.WARNING}[!] {Colors.PRIMARY}Disk space check unavailable")
    
    # Check network connectivity
    try:
        import socket
        socket.create_connection(("8.8.8.8", 53), timeout=3)
        print(f"{Colors.PRIMARY}Network: {Colors.SUCCESS}Connected")
    except:
        print(f"{Colors.WARNING}[!] {Colors.PRIMARY}No internet connection")
    
    print(f"{Colors.INFO}{'‚îÄ' * 100}")
    return requirements_met

def main():
    """Main application entry point with enhanced features"""
    
    # Display initial banner
    scanner = AdvancedScannerPro()
    scanner.display_banner()
    
    # Check system requirements
    if not check_system_requirements():
        print(f"{Colors.ERROR}[‚úó] System requirements not met")
        response = input(f"{Colors.WARNING}[?] Continue anyway? (y/N): ")
        if response.lower() != 'y':
            sys.exit(1)
    
    # Check and install dependencies
    print(f"\n{Colors.INFO}{'‚îÄ' * 100}")
    print(f"{Colors.SCANNER}üì¶ DEPENDENCY MANAGEMENT")
    print(f"{Colors.INFO}{'‚îÄ' * 100}")
    
    all_ok, deps_status, missing, outdated = scanner.dependency_manager.check_all_dependencies()
    
    if not all_ok:
        print(f"\n{Colors.WARNING}[!] {Colors.PRIMARY}Missing: {Colors.ERROR}{len(missing)} {Colors.PRIMARY}| Outdated: {Colors.WARNING}{len(outdated)}")
        
        response = input(f"{Colors.WARNING}[?] Attempt automatic fix? (Y/n): ").strip().lower()
        if response in ['', 'y', 'yes']:
            success, fail = scanner.dependency_manager.auto_fix_dependencies(missing, outdated)
            print(f"\n{Colors.SUCCESS}[‚úì] Fixed: {success} | {Colors.ERROR}Failed: {fail}")
            
            # Re-check dependencies
            all_ok, deps_status, missing, outdated = scanner.dependency_manager.check_all_dependencies()
        else:
            print(f"{Colors.WARNING}[!] Running with incomplete dependencies")
    
    scanner.dependency_status = deps_status
    
    # Check root privileges
    if os.name == 'posix':
        if os.geteuid() != 0:
            print(f"{Colors.WARNING}{'‚ö†' * 100}")
            print(f"{Colors.WARNING} RUNNING WITHOUT ROOT PRIVILEGES")
            print(f"{Colors.WARNING} Some features will be limited")
            print(f"{Colors.WARNING}{'‚ö†' * 100}")
            time.sleep(2)
        else:
            print(f"{Colors.SUCCESS}[‚úì] {Colors.PRIMARY}Running with root privileges")
    
    # Register signal handler
    signal.signal(signal.SIGINT, scanner.signal_handler)
    
    # Load scanners
    scanner.load_scanners()
    
    # Display system info
    print(f"{Colors.INFO}{'‚îÄ' * 100}")
    print(f"{Colors.PRIMARY}System Information:")
    print(f"{Colors.SECONDARY}   ‚îú‚îÄ OS: {Colors.INFO}{os.name}")
    print(f"{Colors.SECONDARY}   ‚îú‚îÄ Platform: {Colors.INFO}{sys.platform}")
    print(f"{Colors.SECONDARY}   ‚îú‚îÄ Python: {Colors.INFO}{sys.version.split()[0]}")
    print(f"{Colors.SECONDARY}   ‚îú‚îÄ CPU Cores: {Colors.INFO}{os.cpu_count()}")
    print(f"{Colors.SECONDARY}   ‚îú‚îÄ Architecture: {Colors.INFO}{platform.architecture()[0]}")
    print(f"{Colors.SECONDARY}   ‚îî‚îÄ Hostname: {Colors.INFO}{socket.gethostname()}")
    print(f"{Colors.INFO}{'‚îÄ' * 100}\n")
    
    # Start menu system
    try:
        from views.menu import MainMenu
        menu = MainMenu(scanner)
        menu.display()
    except ImportError as e:
        print(f"{Colors.ERROR}[‚úó] Menu system error: {e}")
        print(f"{Colors.INFO}[*] Starting command-line interface...")
        scanner.cli_interface()
    except KeyboardInterrupt:
        scanner.signal_handler(None, None)
    except Exception as e:
        print(f"{Colors.ERROR}[‚úó] Fatal error: {Colors.CRITICAL}{e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
    
    # Import platform module if needed
    import platform
    import socket

if __name__ == "__main__":
    main()
